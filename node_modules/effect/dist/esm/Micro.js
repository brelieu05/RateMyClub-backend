import * as Context from "./Context.js";
import * as Effectable from "./Effectable.js";
import * as Either from "./Either.js";
import { constTrue, constVoid, dual, identity } from "./Function.js";
import { globalValue } from "./GlobalValue.js";
import { NodeInspectSymbol, toStringUnknown } from "./Inspectable.js";
import * as doNotation from "./internal/doNotation.js";
import { StructuralPrototype } from "./internal/effectable.js";
import { SingleShotGen } from "./internal/singleShotGen.js";
import * as Option from "./Option.js";
import { pipeArguments } from "./Pipeable.js";
import { isIterable, isTagged } from "./Predicate.js";
import { YieldWrap, yieldWrapGet } from "./Utils.js";
/**
 * @since 3.4.0
 * @experimental
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("effect/Micro");
/**
 * @since 3.4.0
 * @experimental
 * @category symbols
 */
export const runSymbol = /*#__PURE__*/Symbol.for("effect/Micro/runSymbol");
/**
 * @since 3.4.0
 * @experimental
 * @category guards
 */
export const isMicro = u => typeof u === "object" && u !== null && TypeId in u;
// ----------------------------------------------------------------------------
// Failures
// ----------------------------------------------------------------------------
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const FailureTypeId = /*#__PURE__*/Symbol.for("effect/Micro/Failure");
const failureVariance = {
  _E: identity
};
class FailureImpl extends globalThis.Error {
  _tag;
  traces;
  [FailureTypeId];
  constructor(_tag, originalError, traces) {
    const failureName = `Failure${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${failureName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${failureName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = failureName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `\n    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[FailureTypeId] = failureVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class FailureExpectedImpl extends FailureImpl {
  error;
  constructor(error, traces = []) {
    super("Expected", error, traces);
    this.error = error;
  }
}
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const FailureExpected = (error, traces = []) => new FailureExpectedImpl(error, traces);
class FailureUnexpectedImpl extends FailureImpl {
  defect;
  constructor(defect, traces = []) {
    super("Unexpected", defect, traces);
    this.defect = defect;
  }
}
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const FailureUnexpected = (defect, traces = []) => new FailureUnexpectedImpl(defect, traces);
class FailureAbortedImpl extends FailureImpl {
  constructor(traces = []) {
    super("Aborted", "aborted", traces);
  }
}
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const FailureAborted = (traces = []) => new FailureAbortedImpl(traces);
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const failureIsExpected = self => self._tag === "Expected";
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const failureIsUnexpected = self => self._tag === "Unexpected";
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const failureIsAborted = self => self._tag === "Aborted";
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const failureSquash = self => self._tag === "Expected" ? self.error : self._tag === "Unexpected" ? self.defect : self;
/**
 * @since 3.4.0
 * @experimental
 * @category failure
 */
export const failureWithTrace = /*#__PURE__*/dual(2, (self, trace) => {
  if (self._tag === "Expected") {
    return FailureExpected(self.error, [...self.traces, trace]);
  } else if (self._tag === "Unexpected") {
    return FailureUnexpected(self.defect, [...self.traces, trace]);
  }
  return FailureAborted([...self.traces, trace]);
});
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const ResultAborted = /*#__PURE__*/Either.left( /*#__PURE__*/FailureAborted());
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const ResultSuccess = Either.right;
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const ResultFail = e => Either.left(FailureExpected(e));
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const ResultFailUnexpected = defect => Either.left(FailureUnexpected(defect));
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const ResultFailWith = Either.left;
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultIsSuccess = Either.isRight;
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultIsFailure = Either.isLeft;
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultIsAborted = self => resultIsFailure(self) && self.left._tag === "Aborted";
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultIsFailureExpected = self => resultIsFailure(self) && self.left._tag === "Expected";
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultIsFailureUnexpected = self => resultIsFailure(self) && self.left._tag === "Unexpected";
/**
 * @since 3.4.0
 * @experimental
 * @category result
 */
export const resultVoid = /*#__PURE__*/ResultSuccess(void 0);
// ----------------------------------------------------------------------------
// env
// ----------------------------------------------------------------------------
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const EnvTypeId = /*#__PURE__*/Symbol.for("effect/Micro/Env");
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const EnvRefTypeId = /*#__PURE__*/Symbol.for("effect/Micro/EnvRef");
const EnvProto = {
  [EnvTypeId]: {
    _R: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const envMake = refs => {
  const self = Object.create(EnvProto);
  self.refs = refs;
  return self;
};
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const envUnsafeMakeEmpty = () => {
  const controller = new AbortController();
  const refs = Object.create(null);
  refs[currentAbortController.key] = controller;
  refs[currentAbortSignal.key] = controller.signal;
  return envMake(refs);
};
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const envGet = /*#__PURE__*/dual(2, (self, ref) => ref.key in self.refs ? self.refs[ref.key] : ref.initial);
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const envSet = /*#__PURE__*/dual(3, (self, ref, value) => {
  const refs = Object.assign(Object.create(null), self.refs);
  refs[ref.key] = value;
  return envMake(refs);
});
/**
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const envMutate = /*#__PURE__*/dual(2, (self, f) => envMake(f(Object.assign(Object.create(null), self.refs))));
/**
 * Access the given `Context.Tag` from the environment.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const service = tag => make(function (env, onResult) {
  onResult(ResultSuccess(Context.get(envGet(env, currentContext), tag)));
});
/**
 * Access the given `Context.Tag` from the environment, without tracking the
 * dependency at the type level.
 *
 * It will return an `Option` of the service, depending on whether it is
 * available in the environment or not.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const serviceOption = tag => make(function (env, onResult) {
  onResult(ResultSuccess(Context.getOption(envGet(env, currentContext), tag)));
});
/**
 * Retrieve the current value of the given `EnvRef`.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const getEnvRef = envRef => make((env, onResult) => onResult(Either.right(envGet(env, envRef))));
/**
 * Set the value of the given `EnvRef` for the duration of the effect.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const locally = /*#__PURE__*/dual(3, (self, fiberRef, value) => make((env, onResult) => self[runSymbol](envSet(env, fiberRef, value), onResult)));
/**
 * Access the current `Context` from the environment.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const context = () => getEnvRef(currentContext);
/**
 * Merge the given `Context` with the current context.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const provideContext = /*#__PURE__*/dual(2, (self, provided) => make(function (env, onResult) {
  const context = envGet(env, currentContext);
  const nextEnv = envSet(env, currentContext, Context.merge(context, provided));
  self[runSymbol](nextEnv, onResult);
}));
/**
 * Add the provided service to the current context.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const provideService = /*#__PURE__*/dual(3, (self, tag, service) => make(function (env, onResult) {
  const context = envGet(env, currentContext);
  const nextEnv = envSet(env, currentContext, Context.add(context, tag, service));
  self[runSymbol](nextEnv, onResult);
}));
/**
 * Create a service using the provided `Micro` effect, and add it to the
 * current context.
 *
 * @since 3.4.0
 * @experimental
 * @category environment
 */
export const provideServiceMicro = /*#__PURE__*/dual(3, (self, tag, acquire) => flatMap(acquire, service => provideService(self, tag, service)));
// ========================================================================
// Env refs
// ========================================================================
const EnvRefProto = {
  [EnvRefTypeId]: EnvRefTypeId
};
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const envRefMake = (key, initial) => globalValue(key, () => {
  const self = Object.create(EnvRefProto);
  self.key = key;
  self.initial = initial();
  return self;
});
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const currentAbortController = /*#__PURE__*/envRefMake("effect/Micro/currentAbortController", () => undefined);
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const currentAbortSignal = /*#__PURE__*/envRefMake("effect/Micro/currentAbortSignal", () => undefined);
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const currentContext = /*#__PURE__*/envRefMake("effect/Micro/currentContext", () => Context.empty());
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const currentConcurrency = /*#__PURE__*/envRefMake("effect/Micro/currentConcurrency", () => "unbounded");
/**
 * @since 3.4.0
 * @experimental
 * @category environment refs
 */
export const currentMaxDepthBeforeYield = /*#__PURE__*/envRefMake("effect/Micro/currentMaxDepthBeforeYield", () => 2048);
const currentInterruptible = /*#__PURE__*/envRefMake("effect/Micro/currentInterruptible", () => true);
/**
 * If you have a `Micro` that uses `concurrency: "inherit"`, you can use this
 * api to control the concurrency of that `Micro` when it is run.
 *
 * @since 3.4.0
 * @experimental
 * @category environment refs
 * @example
 * import * as Micro from "effect/Micro"
 *
 * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {
 *   concurrency: "inherit"
 * }).pipe(
 *   Micro.withConcurrency(2) // use a concurrency of 2
 * )
 */
export const withConcurrency = /*#__PURE__*/dual(2, (self, concurrency) => locally(self, currentConcurrency, concurrency));
// ----------------------------------------------------------------------------
// constructors
// ----------------------------------------------------------------------------
const MicroProto = {
  ...Effectable.EffectPrototype,
  _op: "Micro",
  [TypeId]: {
    _A: identity,
    _E: identity,
    _R: identity
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  }
};
const microDepthState = /*#__PURE__*/globalValue("effect/Micro/microDepthState", () => ({
  depth: 0,
  maxDepthBeforeYield: currentMaxDepthBeforeYield.initial
}));
const unsafeMake = run => {
  const self = Object.create(MicroProto);
  self[runSymbol] = run;
  return self;
};
const unsafeMakeOptions = (run, checkAbort) => unsafeMake(function execute(env, onResult) {
  if (checkAbort && env.refs[currentInterruptible.key] !== false && env.refs[currentAbortSignal.key].aborted) {
    return onResult(ResultAborted);
  }
  microDepthState.depth++;
  if (microDepthState.depth === 1) {
    microDepthState.maxDepthBeforeYield = envGet(env, currentMaxDepthBeforeYield);
  }
  if (microDepthState.depth >= microDepthState.maxDepthBeforeYield) {
    yieldAdd(() => execute(env, onResult));
  } else {
    try {
      run(env, onResult);
    } catch (err) {
      onResult(ResultFailUnexpected(err));
    }
  }
  microDepthState.depth--;
});
/**
 * A low-level constructor for creating a `Micro` effect. It takes a function
 * that receives an environment and a callback which should be called with the
 * result of the effect.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const make = run => unsafeMakeOptions(run, true);
/**
 * Converts a `Result` into a `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const fromResult = self => make(function (_env, onResult) {
  onResult(self);
});
/**
 * Converts a lazy `Result` into a `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const fromResultSync = self => make(function (_env, onResult) {
  onResult(self());
});
/**
 * Creates a `Micro` effect that will succeed with the specified constant value.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const succeed = a => fromResult(ResultSuccess(a));
/**
 * Creates a `Micro` effect that will succeed with `Option.Some` of the value.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const succeedSome = a => succeed(Option.some(a));
/**
 * Creates a `Micro` effect that will succeed with `Option.None`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const succeedNone = /*#__PURE__*/succeed( /*#__PURE__*/Option.none());
/**
 * Creates a `Micro` effect that will fail with the specified error.
 *
 * This will result in a `FailureExpected`, where the error is tracked at the
 * type level.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const fail = e => fromResult(ResultFail(e));
/**
 * Creates a `Micro` effect that will fail with the lazily evaluated error.
 *
 * This will result in a `FailureExpected`, where the error is tracked at the
 * type level.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const failSync = e => make(function (_env, onResult) {
  onResult(ResultFail(e()));
});
/**
 * Creates a `Micro` effect that will die with the specified error.
 *
 * This will result in a `FailureUnexpected`, where the error is not tracked at
 * the type level.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const die = defect => fromResult(ResultFailUnexpected(defect));
/**
 * Creates a `Micro` effect that will fail with the specified `Failure`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const failWith = failure => fromResult(ResultFailWith(failure));
/**
 * Creates a `Micro` effect that will fail with the lazily evaluated `Failure`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const failWithSync = failure => fromResultSync(() => ResultFailWith(failure()));
/**
 * Creates a `Micro` effect that will succeed with the lazily evaluated value.
 *
 * If the evaluation of the value throws an error, the effect will fail with
 * `FailureUnexpected`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const sync = evaluate => make(function (_env, onResult) {
  onResult(ResultSuccess(evaluate()));
});
/**
 * Converts an `Option` into a `Micro` effect, that will fail with
 * `NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the
 * value of the option.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const fromOption = option => make(function (_env, onResult) {
  onResult(option._tag === "Some" ? ResultSuccess(option.value) : ResultFail(new NoSuchElementException({})));
});
/**
 * Converts an `Either` into a `Micro` effect, that will fail with the left side
 * of the either if it is a `Left`. Otherwise, it will succeed with the right
 * side of the either.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const fromEither = either => make(function (_env, onResult) {
  onResult(either._tag === "Right" ? either : ResultFail(either.left));
});
/**
 * Lazily creates a `Micro` effect from the given side-effect.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const suspend = evaluate => make(function (env, onResult) {
  evaluate()[runSymbol](env, onResult);
});
const void_ = /*#__PURE__*/succeed(void 0);
export {
/**
 * A `Micro` effect that will succeed with `void` (`undefined`).
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
void_ as void };
/**
 * Create a `Micro` effect from an asynchronous computation.
 *
 * You can return a cleanup effect that will be run when the effect is aborted.
 * It is also passed an `AbortSignal` that is triggered when the effect is
 * aborted.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const async = register => make(function (env, onResult) {
  let resumed = false;
  const controller = register.length > 1 ? new AbortController() : undefined;
  const signal = envGet(env, currentAbortSignal);
  let cleanup = undefined;
  function onAbort() {
    if (cleanup) {
      resume(uninterruptible(andThen(cleanup, fromResult(ResultAborted))));
    } else {
      resume(fromResult(ResultAborted));
    }
    if (controller !== undefined) {
      controller.abort();
    }
  }
  function resume(effect) {
    if (resumed) {
      return;
    }
    resumed = true;
    signal.removeEventListener("abort", onAbort);
    effect[runSymbol](env, onResult);
  }
  cleanup = controller === undefined ? register(resume) : register(resume, controller.signal);
  if (resumed) return;
  signal.addEventListener("abort", onAbort);
});
const try_ = options => make(function (_env, onResult) {
  try {
    onResult(ResultSuccess(options.try()));
  } catch (err) {
    onResult(ResultFail(options.catch(err)));
  }
});
export {
/**
 * The `Micro` equivalent of a try / catch block, which allows you to map
 * thrown errors to a specific error type.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 * @example
 * import { Micro } from "effect"
 *
 * Micro.try({
 *   try: () => throw new Error("boom"),
 *   catch: (cause) => new Error("caught", { cause })
 * })
 */
try_ as try };
/**
 * Wrap a `Promise` into a `Micro` effect. Any errors will result in a
 * `FailureUnexpected`.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const promise = evaluate => async(function (resume, signal) {
  evaluate(signal).then(a => resume(succeed(a)), e => resume(die(e)));
});
/**
 * Wrap a `Promise` into a `Micro` effect. Any errors will be caught and
 * converted into a specific error type.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 * @example
 * import { Micro } from "effect"
 *
 * Micro.tryPromise({
 *   try: () => Promise.resolve("success"),
 *   catch: (cause) => new Error("caught", { cause })
 * })
 */
export const tryPromise = options => async(function (resume, signal) {
  try {
    options.try(signal).then(a => resume(succeed(a)), e => resume(fail(options.catch(e))));
  } catch (err) {
    resume(fail(options.catch(err)));
  }
});
const yieldState = /*#__PURE__*/globalValue("effect/Micro/yieldState", () => ({
  tasks: [],
  working: false
}));
const yieldRunTasks = () => {
  const tasks = yieldState.tasks;
  yieldState.tasks = [];
  for (let i = 0, len = tasks.length; i < len; i++) {
    tasks[i]();
  }
};
const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : f => setTimeout(f, 0);
const yieldAdd = task => {
  yieldState.tasks.push(task);
  if (!yieldState.working) {
    yieldState.working = true;
    setImmediate(() => {
      yieldState.working = false;
      yieldRunTasks();
    });
  }
};
/**
 * Pause the execution of the current `Micro` effect, and resume it on the next
 * iteration of the event loop.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const yieldNow = /*#__PURE__*/make(function (_env, onResult) {
  yieldAdd(() => onResult(resultVoid));
});
/**
 * Flush any yielded effects that are waiting to be executed.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const yieldFlush = /*#__PURE__*/sync(function () {
  while (yieldState.tasks.length > 0) {
    yieldRunTasks();
  }
});
/**
 * A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent
 * the Javascript runtime from exiting.
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const never = /*#__PURE__*/async(function () {
  const interval = setInterval(constVoid, 2147483646);
  return sync(() => clearInterval(interval));
});
/**
 * @since 3.4.0
 * @experimental
 * @category constructors
 */
export const gen = (...args) => make(function (env, onResult) {
  const iterator = args.length === 1 ? args[0]() : args[1].call(args[0]);
  let running = false;
  let value = undefined;
  function run() {
    running = true;
    try {
      let shouldContinue = true;
      while (shouldContinue) {
        const result = iterator.next(value);
        if (result.done) {
          return onResult(ResultSuccess(result.value));
        }
        shouldContinue = false;
        yieldWrapGet(result.value)[runSymbol](env, function (result) {
          if (result._tag === "Left") {
            onResult(result);
          } else {
            shouldContinue = true;
            value = result.right;
            if (!running) run();
          }
        });
      }
    } catch (err) {
      onResult(ResultFailUnexpected(err));
    }
    running = false;
  }
  run();
});
// ----------------------------------------------------------------------------
// mapping & sequencing
// ----------------------------------------------------------------------------
/**
 * Flattens any nested `Micro` effects, merging the error and requirement types.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const flatten = self => make(function (env, onResult) {
  self[runSymbol](env, result => result._tag === "Left" ? onResult(result) : result.right[runSymbol](env, onResult));
});
/**
 * Transforms the success value of the `Micro` effect with the specified
 * function.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const map = /*#__PURE__*/dual(2, (self, f) => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    onResult(result._tag === "Left" ? result : ResultSuccess(f(result.right)));
  });
}));
/**
 * Create a `Micro` effect that will replace the success value of the given
 * effect.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const as = /*#__PURE__*/dual(2, (self, value) => map(self, _ => value));
/**
 * Wrap the success value of this `Micro` effect in an `Option.Some`.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const asSome = self => map(self, Option.some);
/**
 * Map the success value of this `Micro` effect to another `Micro` effect, then
 * flatten the result.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const flatMap = /*#__PURE__*/dual(2, (self, f) => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    if (result._tag === "Left") {
      return onResult(result);
    }
    f(result.right)[runSymbol](env, onResult);
  });
}));
/**
 * Swap the error and success types of the `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const flip = self => matchMicro(self, {
  onFailure: succeed,
  onSuccess: fail
});
/**
 * A more flexible version of `flatMap`, that combines `map` and `flatMap` into
 * a single api.
 *
 * It also allows you to pass in a `Micro` effect directly, which will be
 * executed after the current effect.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const andThen = /*#__PURE__*/dual(2, (self, f) => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    if (result._tag === "Left") {
      return onResult(result);
    } else if (envGet(env, currentAbortSignal).aborted) {
      return onResult(ResultAborted);
    }
    const value = isMicro(f) ? f : typeof f === "function" ? f(result.right) : f;
    if (isMicro(value)) {
      value[runSymbol](env, onResult);
    } else {
      onResult(ResultSuccess(value));
    }
  });
}));
/**
 * Execute a side effect from the success value of the `Micro` effect.
 *
 * It is similar to the `andThen` api, but the success value is ignored.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const tap = /*#__PURE__*/dual(2, (self, f) => make(function (env, onResult) {
  self[runSymbol](env, function (selfResult) {
    if (selfResult._tag === "Left") {
      return onResult(selfResult);
    } else if (envGet(env, currentAbortSignal).aborted) {
      return onResult(ResultAborted);
    }
    const value = isMicro(f) ? f : typeof f === "function" ? f(selfResult.right) : f;
    if (isMicro(value)) {
      value[runSymbol](env, function (tapResult) {
        if (tapResult._tag === "Left") {
          return onResult(tapResult);
        }
        onResult(selfResult);
      });
    } else {
      onResult(selfResult);
    }
  });
}));
/**
 * Replace the success value of the `Micro` effect with `void`.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const asVoid = self => map(self, _ => void 0);
/**
 * Access the `Result` of the given `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const asResult = self => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    onResult(ResultSuccess(result));
  });
});
/**
 * Replace the error type of the given `Micro` with the full `Failure` object.
 *
 * @since 3.4.0
 * @experimental
 * @category mapping & sequencing
 */
export const sandbox = self => catchFailure(self, failure => fail(failure));
function forkSignal(env) {
  const controller = new AbortController();
  const parentSignal = envGet(env, currentAbortSignal);
  function onAbort() {
    controller.abort();
    parentSignal.removeEventListener("abort", onAbort);
  }
  parentSignal.addEventListener("abort", onAbort);
  const envWithSignal = envMutate(env, function (refs) {
    refs[currentAbortController.key] = controller;
    refs[currentAbortSignal.key] = controller.signal;
    return refs;
  });
  return [envWithSignal, onAbort];
}
/**
 * Returns an effect that races all the specified effects,
 * yielding the value of the first effect to succeed with a value. Losers of
 * the race will be interrupted immediately
 *
 * @since 3.4.0
 * @experimental
 * @category sequencing
 */
export const raceAll = all => make(function (env, onResult) {
  const [envWithSignal, onAbort] = forkSignal(env);
  const effects = Array.from(all);
  let len = effects.length;
  let index = 0;
  let done = 0;
  let result = undefined;
  const failures = [];
  function onDone(result_) {
    done++;
    if (result_._tag === "Right" && result === undefined) {
      len = index;
      result = result_;
      onAbort();
    } else if (result_._tag === "Left") {
      failures.push(result_.left);
    }
    if (done >= len) {
      onResult(result ?? Either.left(failures[0]));
    }
  }
  for (; index < len; index++) {
    effects[index][runSymbol](envWithSignal, onDone);
  }
});
/**
 * Returns an effect that races all the specified effects,
 * yielding the value of the first effect to succeed or fail. Losers of
 * the race will be interrupted immediately
 *
 * @since 3.4.0
 * @experimental
 * @category sequencing
 */
export const raceAllFirst = all => make(function (env, onResult) {
  const [envWithSignal, onAbort] = forkSignal(env);
  const effects = Array.from(all);
  let len = effects.length;
  let index = 0;
  let done = 0;
  let result = undefined;
  const failures = [];
  function onDone(result_) {
    done++;
    if (result === undefined) {
      len = index;
      result = result_;
      onAbort();
    }
    if (done >= len) {
      onResult(result ?? Either.left(failures[0]));
    }
  }
  for (; index < len; index++) {
    effects[index][runSymbol](envWithSignal, onDone);
  }
});
/**
 * Returns an effect that races two effects, yielding the value of the first
 * effect to succeed. Losers of the race will be interrupted immediately
 *
 * @since 3.4.0
 * @experimental
 * @category sequencing
 */
export const race = /*#__PURE__*/dual(2, (self, that) => raceAll([self, that]));
/**
 * Returns an effect that races two effects, yielding the value of the first
 * effect to succeed *or* fail. Losers of the race will be interrupted immediately
 *
 * @since 3.4.0
 * @experimental
 * @category sequencing
 */
export const raceFirst = /*#__PURE__*/dual(2, (self, that) => raceAllFirst([self, that]));
// ----------------------------------------------------------------------------
// zipping
// ----------------------------------------------------------------------------
/**
 * Combine two `Micro` effects into a single effect that produces a tuple of
 * their results.
 *
 * @since 3.4.0
 * @experimental
 * @category zipping
 */
export const zip = /*#__PURE__*/dual(args => isMicro(args[1]), (self, that, options) => zipWith(self, that, (a, a2) => [a, a2], options));
/**
 * The `Micro.zipWith` function combines two `Micro` effects and allows you to
 * apply a function to the results of the combined effects, transforming them
 * into a single value.
 *
 * @since 3.4.3
 * @experimental
 * @category zipping
 */
export const zipWith = /*#__PURE__*/dual(args => isMicro(args[1]), (self, that, f, options) => {
  if (options?.concurrent) {
    // Use `all` exclusively for concurrent cases, as it introduces additional overhead due to the management of concurrency
    return map(all([self, that], {
      concurrency: "unbounded"
    }), ([a, a2]) => f(a, a2));
  }
  return flatMap(self, a => map(that, a2 => f(a, a2)));
});
// ----------------------------------------------------------------------------
// filtering & conditionals
// ----------------------------------------------------------------------------
/**
 * Filter the specified effect with the provided function, failing with specified
 * `Failure` if the predicate fails.
 *
 * In addition to the filtering capabilities discussed earlier, you have the option to further
 * refine and narrow down the type of the success channel by providing a
 *
 * @since 3.4.0
 * @experimental
 * @category filtering & conditionals
 */
export const filterOrFailWith = /*#__PURE__*/dual(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : failWith(orFailWith(a))));
/**
 * Filter the specified effect with the provided function, failing with specified
 * error if the predicate fails.
 *
 * In addition to the filtering capabilities discussed earlier, you have the option to further
 * refine and narrow down the type of the success channel by providing a
 *
 * @since 3.4.0
 * @experimental
 * @category filtering & conditionals
 */
export const filterOrFail = /*#__PURE__*/dual(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : fail(orFailWith(a))));
/**
 * The moral equivalent of `if (p) exp`.
 *
 * @since 3.4.0
 * @experimental
 * @category filtering & conditionals
 */
export const when = /*#__PURE__*/dual(2, (self, condition) => flatMap(isMicro(condition) ? condition : sync(condition), pass => pass ? asSome(self) : succeed(Option.none())));
// ----------------------------------------------------------------------------
// repetition
// ----------------------------------------------------------------------------
/**
 * Repeat the given `Micro` using the provided options.
 *
 * The `while` predicate will be checked after each iteration, and can use the
 * fall `Result` of the effect to determine if the repetition should continue.
 *
 * @since 3.4.0
 * @experimental
 * @category repetition
 */
export const repeatResult = /*#__PURE__*/dual(2, (self, options) => make(function (env, onResult) {
  const startedAt = options.delay ? Date.now() : 0;
  let attempt = 0;
  self[runSymbol](env, function loop(result) {
    if (options.while !== undefined && !options.while(result)) {
      return onResult(result);
    } else if (options.times !== undefined && attempt >= options.times) {
      return onResult(result);
    }
    attempt++;
    let delayEffect = yieldNow;
    if (options.delay !== undefined) {
      const elapsed = Date.now() - startedAt;
      const duration = options.delay(attempt, elapsed);
      if (Option.isNone(duration)) {
        return onResult(result);
      }
      delayEffect = sleep(duration.value);
    }
    delayEffect[runSymbol](env, function (result) {
      if (result._tag === "Left") {
        return onResult(result);
      }
      self[runSymbol](env, loop);
    });
  });
}));
/**
 * Repeat the given `Micro` effect using the provided options. Only successful
 * results will be repeated.
 *
 * @since 3.4.0
 * @experimental
 * @category repetition
 */
export const repeat = /*#__PURE__*/dual(args => isMicro(args[0]), (self, options) => repeatResult(self, {
  ...options,
  while: result => result._tag === "Right" && (options?.while === undefined || options.while(result.right))
}));
/**
 * Repeat the given `Micro` effect forever, only stopping if the effect fails.
 *
 * @since 3.4.0
 * @experimental
 * @category repetition
 */
export const forever = self => repeat(self);
/**
 * Create a `DelayFn` that will generate a duration with an exponential backoff.
 *
 * @since 3.4.0
 * @experimental
 * @category delay fn
 */
export const delayExponential = (baseMillis, factor = 2) => attempt => Option.some(attempt ** factor * baseMillis);
/**
 * Create a `DelayFn` that will generate a duration with fixed intervals.
 *
 * @since 3.4.0
 * @experimental
 * @category delay fn
 */
export const delaySpaced = millis => _ => Option.some(millis);
/**
 * Transform a `DelayFn` to one that will have a duration that will never exceed
 * the specified maximum.
 *
 * @since 3.4.0
 * @experimental
 * @category delay fn
 */
export const delayWithMax = /*#__PURE__*/dual(2, (self, max) => (attempt, elapsed) => Option.map(self(attempt, elapsed), duration => Math.min(duration, max)));
/**
 * Transform a `DelayFn` to one that will stop repeating after the specified
 * amount of time.
 *
 * @since 3.4.0
 * @experimental
 * @category delay fn
 */
export const delayWithMaxElapsed = /*#__PURE__*/dual(2, (self, max) => (attempt, elapsed) => elapsed < max ? self(attempt, elapsed) : Option.none());
/**
 * Transform a `DelayFn` to one that will stop repeating after the specified
 * number of attempts.
 *
 * @since 3.4.0
 * @experimental
 * @category delay fn
 */
export const delayWithRecurs = /*#__PURE__*/dual(2, (self, n) => (attempt, elapsed) => Option.filter(self(attempt, elapsed), () => attempt <= n));
// ----------------------------------------------------------------------------
// error handling
// ----------------------------------------------------------------------------
/**
 * Catch the full `Failure` object of the given `Micro` effect, allowing you to
 * recover from any kind of failure.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchFailure = /*#__PURE__*/dual(2, (self, f) => catchFailureIf(self, constTrue, f));
/**
 * Selectively catch a `Failure` object of the given `Micro` effect,
 * using the provided predicate to determine if the failure should be caught.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchFailureIf = /*#__PURE__*/dual(3, (self, refinement, f) => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    if (result._tag === "Right" || !refinement(result.left)) {
      return onResult(result);
    }
    f(result.left)[runSymbol](env, onResult);
  });
}));
/**
 * Catch the error of the given `Micro` effect, allowing you to recover from it.
 *
 * It only catches expected (`FailureExpected`) errors.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchExpected = /*#__PURE__*/dual(2, (self, f) => catchFailureIf(self, failureIsExpected, failure => f(failure.error)));
/**
 * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchUnexpected = /*#__PURE__*/dual(2, (self, f) => catchFailureIf(self, failureIsUnexpected, failure => f(failure.defect)));
/**
 * Perform a side effect using the full `Failure` object of the given `Micro`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const tapFailure = /*#__PURE__*/dual(2, (self, f) => tapFailureIf(self, constTrue, f));
/**
 * Perform a side effect using if a `Failure` object matches the specified
 * predicate.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const tapFailureIf = /*#__PURE__*/dual(3, (self, refinement, f) => catchFailureIf(self, refinement, failure => andThen(f(failure), failWith(failure))));
/**
 * Perform a side effect from expected errors of the given `Micro`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const tapExpected = /*#__PURE__*/dual(2, (self, f) => tapFailureIf(self, failureIsExpected, failure => f(failure.error)));
/**
 * Perform a side effect from unexpected errors of the given `Micro`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const tapUnexpected = /*#__PURE__*/dual(2, (self, f) => tapFailureIf(self, failureIsUnexpected, failure => f(failure.defect)));
/**
 * Catch any expected errors that match the specified predicate.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchIf = /*#__PURE__*/dual(3, (self, predicate, f) => catchFailureIf(self, f => failureIsExpected(f) && predicate(f.error), failure => f(failure.error)));
/**
 * Recovers from the specified tagged error.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const catchTag = /*#__PURE__*/dual(3, (self, k, f) => catchIf(self, isTagged(k), f));
/**
 * Transform the full `Failure` object of the given `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const mapFailure = /*#__PURE__*/dual(2, (self, f) => catchFailure(self, failure => failWith(f(failure))));
/**
 * Transform any expected errors of the given `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const mapError = /*#__PURE__*/dual(2, (self, f) => catchExpected(self, error => fail(f(error))));
/**
 * Elevate any expected errors of the given `Micro` effect to unexpected errors,
 * resulting in an error type of `never`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const orDie = self => catchExpected(self, die);
/**
 * Recover from all errors by succeeding with the given value.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const orElseSucceed = /*#__PURE__*/dual(2, (self, f) => catchExpected(self, _ => sync(f)));
/**
 * Ignore any expected errors of the given `Micro` effect, returning `void`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const ignore = self => matchMicro(self, {
  onFailure: _ => void_,
  onSuccess: _ => void_
});
/**
 * Ignore any expected errors of the given `Micro` effect, returning `void`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const ignoreLogged = self => matchMicro(self, {
  onFailure: failure => sync(() => console.error(failure)),
  onSuccess: _ => void_
});
/**
 * Replace the success value of the given `Micro` effect with an `Option`,
 * wrapping the success value in `Some` and returning `None` if the effect fails
 * with an expected error.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const option = self => match(self, {
  onFailure: _ => Option.none(),
  onSuccess: Option.some
});
/**
 * Replace the success value of the given `Micro` effect with an `Either`,
 * wrapping the success value in `Right` and wrapping any expected errors with
 * a `Left`.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const either = self => match(self, {
  onFailure: Either.left,
  onSuccess: Either.right
});
/**
 * Retry the given `Micro` effect using the provided options.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const retry = /*#__PURE__*/dual(args => isMicro(args[0]), (self, options) => repeatResult(self, {
  ...options,
  while: result => result._tag === "Left" && result.left._tag === "Expected" && (options?.while === undefined || options.while(result.left.error))
}));
/**
 * Add a stack trace to any failures that occur in the effect. The trace will be
 * added to the `traces` field of the `Failure` object.
 *
 * @since 3.4.0
 * @experimental
 * @category error handling
 */
export const withTrace = function () {
  const prevLimit = globalThis.Error.stackTraceLimit;
  globalThis.Error.stackTraceLimit = 2;
  const error = new globalThis.Error();
  globalThis.Error.stackTraceLimit = prevLimit;
  function generate(name, failure) {
    const stack = error.stack;
    if (!stack) {
      return failure;
    }
    const line = stack.split("\n")[2]?.trim().replace(/^at /, "");
    if (!line) {
      return failure;
    }
    const lineMatch = line.match(/\((.*)\)$/);
    return failureWithTrace(failure, `at ${name} (${lineMatch ? lineMatch[1] : line})`);
  }
  const f = name => self => unsafeMakeOptions(function (env, onResult) {
    self[runSymbol](env, function (result) {
      onResult(result._tag === "Left" ? Either.left(generate(name, result.left)) : result);
    });
  }, false);
  if (arguments.length === 2) {
    return f(arguments[1])(arguments[0]);
  }
  return f(arguments[0]);
};
// ----------------------------------------------------------------------------
// pattern matching
// ----------------------------------------------------------------------------
/**
 * @since 3.4.0
 * @experimental
 * @category pattern matching
 */
export const matchFailureMicro = /*#__PURE__*/dual(2, (self, options) => make(function (env, onResult) {
  self[runSymbol](env, function (result) {
    try {
      const next = result._tag === "Left" ? options.onFailure(result.left) : options.onSuccess(result.right);
      next[runSymbol](env, onResult);
    } catch (err) {
      onResult(ResultFailUnexpected(err));
    }
  });
}));
/**
 * @since 3.4.0
 * @experimental
 * @category pattern matching
 */
export const matchFailure = /*#__PURE__*/dual(2, (self, options) => matchFailureMicro(self, {
  onFailure: failure => sync(() => options.onFailure(failure)),
  onSuccess: value => sync(() => options.onSuccess(value))
}));
/**
 * @since 3.4.0
 * @experimental
 * @category pattern matching
 */
export const matchMicro = /*#__PURE__*/dual(2, (self, options) => matchFailureMicro(self, {
  onFailure: failure => failure._tag === "Expected" ? options.onFailure(failure.error) : failWith(failure),
  onSuccess: options.onSuccess
}));
/**
 * @since 3.4.0
 * @experimental
 * @category pattern matching
 */
export const match = /*#__PURE__*/dual(2, (self, options) => matchMicro(self, {
  onFailure: error => sync(() => options.onFailure(error)),
  onSuccess: value => sync(() => options.onSuccess(value))
}));
// ----------------------------------------------------------------------------
// delays & timeouts
// ----------------------------------------------------------------------------
/**
 * Create a `Micro` effect that will sleep for the specified duration.
 *
 * @since 3.4.0
 * @experimental
 * @category delays & timeouts
 */
export const sleep = millis => async(function (resume) {
  const timeout = setTimeout(function () {
    resume(void_);
  }, millis);
  return sync(() => {
    return clearTimeout(timeout);
  });
});
/**
 * Returns an effect that will delay the execution of this effect by the
 * specified duration.
 *
 * @since 3.4.0
 * @experimental
 * @category delays & timeouts
 */
export const delay = /*#__PURE__*/dual(2, (self, millis) => andThen(sleep(millis), self));
/**
 * Returns an effect that will timeout this effect, that will execute the
 * fallback effect if the timeout elapses before the effect has produced a value.
 *
 * If the timeout elapses, the running effect will be safely interrupted.
 *
 * @since 3.4.0
 * @experimental
 * @category delays & timeouts
 */
export const timeoutOrElse = /*#__PURE__*/dual(2, (self, options) => raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout)));
/**
 * Returns an effect that will timeout this effect, succeeding with a `None`
 * if the timeout elapses before the effect has produced a value; and `Some` of
 * the produced value otherwise.
 *
 * If the timeout elapses, the running effect will be safely interrupted.
 *
 * @since 3.4.0
 * @experimental
 * @category delays & timeouts
 */
export const timeout = /*#__PURE__*/dual(2, (self, millis) => raceFirst(asSome(self), as(interruptible(sleep(millis)), Option.none())));
// ----------------------------------------------------------------------------
// resources & finalization
// ----------------------------------------------------------------------------
/**
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const MicroScopeTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroScope");
/**
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const MicroScope = /*#__PURE__*/Context.GenericTag("effect/Micro/MicroScope");
class ScopeImpl {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer);
    }
  }
  addFinalizer(finalizer) {
    return suspend(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer);
        return void_;
      }
      return finalizer(this.state.result);
    });
  }
  unsafeRemoveFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer);
    }
  }
  close(result) {
    return suspend(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          result
        };
        return flatMap(forEach(finalizers, finalizer => asResult(finalizer(result))), results => asVoid(fromResult(Either.all(results))));
      }
      return void_;
    });
  }
  get fork() {
    return sync(() => {
      const newScope = new ScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(result) {
        return newScope.close(result);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer(_ => sync(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
}
/**
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const scopeMake = /*#__PURE__*/sync(() => new ScopeImpl());
/**
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const scopeUnsafeMake = () => new ScopeImpl();
/**
 * Access the current `MicroScope`.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const scope = /*#__PURE__*/service(MicroScope);
/**
 * Provide a `MicroScope` to an effect.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const provideScope = /*#__PURE__*/dual(2, (self, scope) => provideService(self, MicroScope, scope));
/**
 * Provide a `MicroScope` to the given effect, closing it after the effect has
 * finished executing.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const scoped = self => suspend(function () {
  const scope = new ScopeImpl();
  return onResult(provideService(self, MicroScope, scope), result => scope.close(result));
});
/**
 * Create a resource with a cleanup `Micro` effect, ensuring the cleanup is
 * executed when the `MicroScope` is closed.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const acquireRelease = (acquire, release) => uninterruptible(flatMap(scope, scope => tap(acquire, a => scope.addFinalizer(result => release(a, result)))));
/**
 * Add a finalizer to the current `MicroScope`.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const addFinalizer = finalizer => flatMap(scope, scope => scope.addFinalizer(finalizer));
/**
 * When the `Micro` effect is completed, run the given finalizer effect with the
 * `Result` of the executed effect.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const onResult = /*#__PURE__*/dual(2, (self, f) => onResultIf(self, constTrue, f));
/**
 * When the `Micro` effect is completed, run the given finalizer effect if it
 * matches the specified predicate.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const onResultIf = /*#__PURE__*/dual(3, (self, refinement, f) => uninterruptibleMask(restore => make(function (env, onResult) {
  restore(self)[runSymbol](env, function (result) {
    if (!refinement(result)) {
      return onResult(result);
    }
    f(result)[runSymbol](env, function (finalizerResult) {
      if (finalizerResult._tag === "Left") {
        return onResult(finalizerResult);
      }
      onResult(result);
    });
  });
})));
/**
 * Regardless of the result of the this `Micro` effect, run the finalizer effect.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const ensuring = /*#__PURE__*/dual(2, (self, finalizer) => onResult(self, _ => finalizer));
/**
 * When the `Micro` effect fails, run the given finalizer effect with the
 * `Failure` of the executed effect.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const onFailure = /*#__PURE__*/dual(2, (self, f) => onResultIf(self, resultIsFailure, result => f(result.left)));
/**
 * If this `Micro` effect is aborted, run the finalizer effect.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const onAbort = /*#__PURE__*/dual(2, (self, finalizer) => onResultIf(self, resultIsAborted, _ => finalizer));
/**
 * Acquire a resource, use it, and then release the resource when the `use`
 * effect has completed.
 *
 * @since 3.4.0
 * @experimental
 * @category resources & finalization
 */
export const acquireUseRelease = (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(asResult(restore(use(a))), result => andThen(release(a, result), fromResult(result)))));
// ----------------------------------------------------------------------------
// interruption
// ----------------------------------------------------------------------------
/**
 * Abort the current `Micro` effect.
 *
 * @since 3.4.0
 * @experimental
 * @category interruption
 */
export const abort = /*#__PURE__*/make(function (env, onResult) {
  const controller = envGet(env, currentAbortController);
  controller.abort();
  onResult(ResultAborted);
});
/**
 * Wrap the given `Micro` effect in an uninterruptible region, preventing the
 * effect from being aborted.
 *
 * @since 3.4.0
 * @experimental
 * @category interruption
 */
export const uninterruptible = self => unsafeMakeOptions(function (env, onResult) {
  const nextEnv = envMutate(env, function (env) {
    env[currentInterruptible.key] = false;
    env[currentAbortSignal.key] = new AbortController().signal;
    return env;
  });
  self[runSymbol](nextEnv, onResult);
}, false);
/**
 * Wrap the given `Micro` effect in an uninterruptible region, preventing the
 * effect from being aborted.
 *
 * You can use the `restore` function to restore a `Micro` effect to the
 * interruptibility state before the `uninterruptibleMask` was applied.
 *
 * @since 3.4.0
 * @experimental
 * @category interruption
 * @example
 * import * as Micro from "effect/Micro"
 *
 * Micro.uninterruptibleMask((restore) =>
 *   Micro.sleep(1000).pipe( // uninterruptible
 *     Micro.andThen(restore(Micro.sleep(1000))) // interruptible
 *   )
 * )
 */
export const uninterruptibleMask = f => unsafeMakeOptions((env, onResult) => {
  const isInterruptible = envGet(env, currentInterruptible);
  const effect = isInterruptible ? f(interruptible) : f(identity);
  const nextEnv = isInterruptible ? envMutate(env, function (env) {
    env[currentInterruptible.key] = false;
    env[currentAbortSignal.key] = new AbortController().signal;
    return env;
  }) : env;
  effect[runSymbol](nextEnv, onResult);
}, false);
/**
 * Wrap the given `Micro` effect in an interruptible region, allowing the effect
 * to be aborted.
 *
 * @since 3.4.0
 * @experimental
 * @category interruption
 */
export const interruptible = self => make((env, onResult) => {
  const isInterruptible = envGet(env, currentInterruptible);
  let newEnv = env;
  if (!isInterruptible) {
    const controller = envGet(env, currentAbortController);
    newEnv = envMutate(env, function (env) {
      env[currentInterruptible.key] = true;
      env[currentAbortSignal.key] = controller.signal;
      return env;
    });
  }
  self[runSymbol](newEnv, onResult);
});
/**
 * Runs all the provided effects in sequence respecting the structure provided in input.
 *
 * Supports multiple arguments, a single argument tuple / array or record / struct.
 *
 * @since 3.4.0
 * @experimental
 * @category collecting & elements
 */
export const all = (arg, options) => {
  if (Array.isArray(arg) || isIterable(arg)) {
    return forEach(arg, identity, options);
  } else if (options?.discard) {
    return forEach(Object.values(arg), identity, options);
  }
  return suspend(() => {
    const out = {};
    return as(forEach(Object.entries(arg), ([key, effect]) => map(effect, value => {
      out[key] = value;
    }), {
      discard: true,
      concurrency: options?.concurrency
    }), out);
  });
};
/**
 * For each element of the provided iterable, run the effect and collect the results.
 *
 * If the `discard` option is set to `true`, the results will be discarded and
 * the effect will return `void`.
 *
 * The `concurrency` option can be set to control how many effects are run in
 * parallel. By default, the effects are run sequentially.
 *
 * @since 3.4.0
 * @experimental
 * @category collecting & elements
 */
export const forEach = (iterable, f, options) => make(function (env, onResult) {
  const concurrencyOption = options?.concurrency === "inherit" ? envGet(env, currentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  // abort
  const [envWithSignal, onAbort] = forkSignal(env);
  // iterate
  let failure = undefined;
  const items = Array.from(iterable);
  let length = items.length;
  const out = options?.discard ? undefined : new Array(length);
  let index = 0;
  let inProgress = 0;
  let doneCount = 0;
  let pumping = false;
  function pump() {
    pumping = true;
    while (inProgress < concurrency && index < length) {
      const currentIndex = index;
      const item = items[currentIndex];
      index++;
      inProgress++;
      try {
        f(item, currentIndex)[runSymbol](envWithSignal, function (result) {
          if (result._tag === "Left") {
            if (failure === undefined) {
              failure = result;
              length = index;
              onAbort();
            }
          } else if (out !== undefined) {
            out[currentIndex] = result.right;
          }
          doneCount++;
          inProgress--;
          if (doneCount === length) {
            onResult(failure ?? Either.right(out));
          } else if (!pumping && inProgress < concurrency) {
            pump();
          }
        });
      } catch (err) {
        failure = ResultFailUnexpected(err);
        length = index;
        onAbort();
      }
    }
    pumping = false;
  }
  pump();
});
/**
 * Effectfully filter the elements of the provided iterable.
 *
 * Use the `concurrency` option to control how many elements are processed in parallel.
 *
 * @since 3.4.0
 * @experimental
 * @category collecting & elements
 */
export const filter = (iterable, f, options) => filterMap(iterable, a => map(f(a), pass => {
  pass = options?.negate ? !pass : pass;
  return pass ? Option.some(a) : Option.none();
}));
/**
 * Effectfully filter the elements of the provided iterable.
 *
 * Use the `concurrency` option to control how many elements are processed in parallel.
 *
 * @since 3.4.0
 * @experimental
 * @category collecting & elements
 */
export const filterMap = (iterable, f, options) => suspend(() => {
  const out = [];
  return as(forEach(iterable, a => map(f(a), o => {
    if (o._tag === "Some") {
      out.push(o.value);
    }
  }), {
    discard: true,
    concurrency: options?.concurrency
  }), out);
});
// ----------------------------------------------------------------------------
// do notation
// ----------------------------------------------------------------------------
/**
 * Start a do notation block.
 *
 * @since 3.4.0
 * @experimental
 * @category do notation
 */
export const Do = /*#__PURE__*/succeed({});
/**
 * Bind the success value of this `Micro` effect to the provided name.
 *
 * @since 3.4.0
 * @experimental
 * @category do notation
 */
export const bindTo = /*#__PURE__*/doNotation.bindTo(map);
/**
 * Bind the success value of this `Micro` effect to the provided name.
 *
 * @since 3.4.0
 * @experimental
 * @category do notation
 */
export const bind = /*#__PURE__*/doNotation.bind(map, flatMap);
const let_ = /*#__PURE__*/doNotation.let_(map);
export {
/**
 * Bind the result of a synchronous computation to the given name.
 *
 * @since 3.4.0
 * @experimental
 * @category do notation
 */
let_ as let };
// ----------------------------------------------------------------------------
// handle & forking
// ----------------------------------------------------------------------------
/**
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const HandleTypeId = /*#__PURE__*/Symbol.for("effect/Micro/Handle");
/**
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const isHandle = u => typeof u === "object" && u !== null && HandleTypeId in u;
class HandleImpl {
  parentSignal;
  [HandleTypeId];
  observers = new Set();
  _result = undefined;
  _controller;
  isRoot;
  constructor(parentSignal, controller) {
    this.parentSignal = parentSignal;
    this[HandleTypeId] = HandleTypeId;
    this.isRoot = controller !== undefined;
    this._controller = controller ?? new AbortController();
    if (!this.isRoot) {
      parentSignal.addEventListener("abort", this.unsafeAbort);
    }
  }
  unsafePoll() {
    return this._result ?? null;
  }
  unsafeAbort = () => {
    this._controller.abort();
  };
  emit(result) {
    if (this._result) {
      return;
    }
    this._result = result;
    if (!this.isRoot) {
      this.parentSignal.removeEventListener("abort", this.unsafeAbort);
    }
    this.observers.forEach(observer => observer(result));
    this.observers.clear();
  }
  addObserver(observer) {
    if (this._result) {
      return observer(this._result);
    }
    this.observers.add(observer);
  }
  removeObserver(observer) {
    this.observers.delete(observer);
  }
  get await() {
    return suspend(() => {
      if (this._result) {
        return succeed(this._result);
      }
      return async(resume => {
        function observer(result) {
          resume(succeed(result));
        }
        this.addObserver(observer);
        return sync(() => {
          this.removeObserver(observer);
        });
      });
    });
  }
  get join() {
    return flatMap(this.await, fromResult);
  }
  get abort() {
    return suspend(() => {
      this.unsafeAbort();
      return this.await;
    });
  }
}
/**
 * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or
 * aborted.
 *
 * When the parent `Micro` finishes, this `Micro` will be aborted.
 *
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const fork = self => make(function (env, onResult) {
  const signal = envGet(env, currentAbortSignal);
  const handle = new HandleImpl(signal);
  const nextEnv = envMutate(env, map => {
    map[currentAbortController.key] = handle._controller;
    map[currentAbortSignal.key] = handle._controller.signal;
    return map;
  });
  yieldAdd(() => {
    self[runSymbol](nextEnv, result => {
      handle.emit(result);
    });
  });
  onResult(Either.right(handle));
});
/**
 * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or
 * aborted.
 *
 * It will not be aborted when the parent `Micro` finishes.
 *
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const forkDaemon = self => make(function (env, onResult) {
  const controller = new AbortController();
  const handle = new HandleImpl(controller.signal, controller);
  const nextEnv = envMutate(env, map => {
    map[currentAbortController.key] = controller;
    map[currentAbortSignal.key] = controller.signal;
    return map;
  });
  yieldAdd(() => {
    self[runSymbol](nextEnv, result => {
      handle.emit(result);
    });
  });
  onResult(Either.right(handle));
});
/**
 * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or
 * aborted.
 *
 * The lifetime of the handle will be attached to the provided `MicroScope`.
 *
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const forkIn = /*#__PURE__*/dual(2, (self, scope) => uninterruptibleMask(restore => flatMap(scope.fork, scope => tap(restore(forkDaemon(onResult(self, result => scope.close(result)))), fiber => scope.addFinalizer(_ => asVoid(fiber.abort))))));
/**
 * Run the `Micro` effect in a new `Handle` that can be awaited, joined, or
 * aborted.
 *
 * The lifetime of the handle will be attached to the current `MicroScope`.
 *
 * @since 3.4.0
 * @experimental
 * @category handle & forking
 */
export const forkScoped = self => flatMap(scope, scope => forkIn(self, scope));
// ----------------------------------------------------------------------------
// execution
// ----------------------------------------------------------------------------
/**
 * Execute the `Micro` effect and return a `Handle` that can be awaited, joined,
 * or aborted.
 *
 * You can listen for the result by adding an observer using the handle's
 * `addObserver` method.
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 * @example
 * import * as Micro from "effect/Micro"
 *
 * const handle = Micro.succeed(42).pipe(
 *   Micro.delay(1000),
 *   Micro.runFork
 * )
 *
 * handle.addObserver((result) => {
 *   console.log(result)
 * })
 */
export const runFork = (effect, options) => {
  const controller = new AbortController();
  const refs = Object.create(null);
  refs[currentAbortController.key] = controller;
  refs[currentAbortSignal.key] = controller.signal;
  const env = envMake(refs);
  const handle = new HandleImpl(controller.signal, controller);
  effect[runSymbol](envSet(env, currentAbortSignal, handle._controller.signal), result => {
    handle.emit(result);
    if (options?.signal) {
      options.signal.removeEventListener("abort", handle.unsafeAbort);
    }
  });
  if (options?.signal) {
    if (options.signal.aborted) {
      handle.unsafeAbort();
    } else {
      options.signal.addEventListener("abort", handle.unsafeAbort, {
        once: true
      });
    }
  }
  return handle;
};
/**
 * Execute the `Micro` effect and return a `Promise` that resolves with the
 * `Result` of the computation.
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 */
export const runPromiseResult = (effect, options) => new Promise((resolve, _reject) => {
  const handle = runFork(effect, options);
  handle.addObserver(resolve);
});
/**
 * Execute the `Micro` effect and return a `Promise` that resolves with the
 * successful value of the computation.
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 */
export const runPromise = (effect, options) => runPromiseResult(effect, options).then(result => {
  if (result._tag === "Left") {
    throw result.left;
  }
  return result.right;
});
/**
 * Attempt to execute the `Micro` effect synchronously and return the `Result`.
 *
 * If any asynchronous effects are encountered, the function will return a
 * FailureUnexpected containing the `Handle`.
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 */
export const runSyncResult = effect => {
  const handle = runFork(effect);
  while (yieldState.tasks.length > 0) {
    yieldRunTasks();
  }
  const result = handle.unsafePoll();
  if (result === null) {
    return ResultFailUnexpected(handle);
  }
  return result;
};
/**
 * Attempt to execute the `Micro` effect synchronously and return the success
 * value.
 *
 * @since 3.4.0
 * @experimental
 * @category execution
 */
export const runSync = effect => {
  const result = runSyncResult(effect);
  if (result._tag === "Left") {
    throw result.left;
  }
  return result.right;
};
const YieldableError = /*#__PURE__*/function () {
  class YieldableError extends globalThis.Error {
    [runSymbol](_env, onResult) {
      onResult(ResultFail(this));
    }
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    }
    toJSON() {
      return {
        ...this
      };
    }
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}\n${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  }
  Object.assign(YieldableError.prototype, MicroProto, StructuralPrototype);
  return YieldableError;
}();
/**
 * @since 3.4.0
 * @experimental
 * @category errors
 */
export const Error = /*#__PURE__*/function () {
  return class extends YieldableError {
    constructor(args) {
      super();
      if (args) {
        Object.assign(this, args);
      }
    }
  };
}();
/**
 * @since 3.4.0
 * @experimental
 * @category errors
 */
export const TaggedError = tag => {
  class Base extends Error {
    _tag = tag;
  }
  ;
  Base.prototype.name = tag;
  return Base;
};
/**
 * Represents a checked exception which occurs when an expected element was
 * unable to be found.
 *
 * @since 3.4.4
 * @experimental
 * @category errors
 */
export class NoSuchElementException extends TaggedError("NoSuchElementException") {}
//# sourceMappingURL=Micro.js.map